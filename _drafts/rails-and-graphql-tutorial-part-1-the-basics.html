---
layout: post
title: Rails and GraphQL Tutorial Part 1 - The Basics
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories:
- Ruby on Rails
- Tutorials
tags: []
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '1'
author:
  login: admin
  email: mengledowl@gmail.com
  display_name: Matt Engledowl
  first_name: ''
  last_name: ''
permalink: "/"
---
<p>Welcome to my first post in a series I will be starting about creating a GraphQL API in ruby on rails!</p>
<p><strong>If you are new to using GraphQL in rails and to my blog, you can safely skip this section and jump straight into the tutorial.</strong> (<em>Or if you just don't really care about the reasons that I'm writing another tutorial :))</em></p>
<p>Before we get to the actual tutorial, a bit of housekeeping is in order. If you've followed me before now, you probably know that this isn't the first time I've written a tutorial for these two technologies. So you might be wondering: "why now; why another tutorial?"</p>
<p><strong>To answer the first question</strong> about the timing: the <code>graphql</code> ruby gem has long used a "constant-style" syntax for defining types and procs for resolvers. Robert has been hard at work to create a new class-based API that will be much more familiar to rubyists who are more used to using classes and OOP than the more functional style previously used. Recently, these changes went live in the gem. I've been waiting for this to happen so that I could write tutorials using this new (and much improved) way of doing things.</p>
<p><strong>The second question</strong> is partly answered by the above: with the new syntax, my previous tutorials are somewhat outdated. Not that you can't still use that method of defining things in the new version - the <code>define</code> style (what was previously used to create types) will continue to work until it gets sunset, which I believe is currently slated for 1.10 - but really this new class-based syntax is a much better and more straightforward way of working with the gem.</p>
<p>The other reason I'm doing another tutorial is that I've been meaning to create something more cohesive. If you look back through my <a href="https://graphqlme.com/2017/09/04/building-a-graphql-api-in-rails/">previous</a> <a href="https://graphqlme.com/2017/09/24/graphql-connections-rails/">posts</a> <a href="https://graphqlme.com/2017/09/30/presenterdecorator-pattern-in-graphql-rails/">under</a> the <a href="https://graphqlme.com/2017/11/04/input-types/">Tutorials</a> <a href="https://graphqlme.com/2017/12/09/n1-queries-no-more/">category</a>, you'll notice that they don't really flow from one to the next. They're pretty much entirely separate from each other, which works alright if you're just looking for one-off answers for "how do I do x", but I really want to provide something where someone new to GraphQL can come in and get a full picture, from concept to schema design, and then to full GraphQL API in a series-like format.</p>
<h2>Let's Get On With It</h2>
<p>Throughout this tutorial, you'll be building a simple social network for ice cream fanatics. I'm going to assume that you have at least a basic understanding of both ruby and rails, and at least have some understanding of GraphQL. If you're not familiar with the basic concepts of GraphQL, I would recommend spending some time reading about it before continuing, although it is not necessarily required to do so.</p>
<p>I should specify that <strong>there will be no incorporation of the client-side, or front-end, of this project</strong>. We <em>will</em> go through schema design, discuss best practices, and programatic implementation of the API itself though.</p>
<h3>Setup</h3>
<p>Let's get cranking! We'll start with the obvious stuff. Create a new rails API with postgres as the database adapter:</p>
<pre class="p1"><span class="s1">$ rails</span> <span class="s3">new</span> <span class="s3">icecream-craze</span> <span class="s3">--api</span> <span class="s3">--database=postgresql</span></pre>
<p>Next we cd into our new app and create the database:</p>
<pre>$ cd icecream-craze
$ rails db:create</pre>
<p>I'm also a fan of rspec for tests, so go ahead and delete the <code>test</code> directory, add <code>gem 'rspec-rails'</code> to your Gemfile, and do:</p>
<pre>$ bundle install
$ rails g rspec:install</pre>
<p>This should generate everything you need for rspec.</p>
<p>Now we can get to the thing we came here for: graphql! Add <code>gem 'graphql'</code> to your Gemfile and install it:</p>
<pre>$ bundle install
$ rails g graphql:install</pre>
<p>That last command is going to create several files and directories for you, as well as adding a new route to your routes file. (Note: at time of writing, the gem is at 1.8.4)</p>
<h3>What That Command Did</h3>
<p>If you're already at least somewhat familiar with GraphQL, then you know that one of the main ideas with GraphQL is that you have a <em>single endpoint</em> for all of your requests to go through (generally speaking, anyway). To that end, we've now got a new route in <code>routes.rb</code>:</p>
<p><script src="https://gist.github.com/mengledowl/f73f513458e5370589e4d80913f85cd3.js?file=graphql_controller.rb"></script></p>
<p>&nbsp;</p>
<pre># config/routes.rb</pre>
<pre>Rails.application.routes.draw do
  post "/graphql", to: "graphql#execute"
  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
end</pre>
<p>So we've got a single route that points <code>/graphql</code> to <code>GraphqlController#execute</code> - which leads us to the next thing that the install command did: it created a new controller for us! Since GraphQL uses a single endpoint, <em>this is the only controller we're going to need</em>. That might seem a bit strange, but trust me, it's powerful!</p>
<p>So here's what our new controller looks like:</p>
<pre># app/controllers/graphql_controller.rb

class GraphqlController &lt; ApplicationController
  def execute
    variables = ensure_hash(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      # Query context goes here, for example:
      # current_user: current_user,
    }
    result = IcecreamCrazeSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  end

  private

  # Handle form data, JSON body, or a blank value
  def ensure_hash(ambiguous_param)
    case ambiguous_param
    when String
      if ambiguous_param.present?
        ensure_hash(JSON.parse(ambiguous_param))
      else
        {}
      end
    when Hash, ActionController::Parameters
      ambiguous_param
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{ambiguous_param}"
    end
  end
end</pre>
<p>And what does this do exactly? The exact details aren't that important for us right now - the important thing to know here is that the line that starts with <code>result = IcecreamCrazeSchema.execute</code> is where we jump out of our controller and into GraphQL. The <code>execute</code> method takes the query that came from the client-side, and outputs the results of that query.</p>
<p>The other important thing that this command did was it generated a new <code>app/graphql</code> directory, with a few sub-directories and example files.</p>
<p>The first file is <code>app/graphql/icecream_craze_schema.rb</code> - the entry point we discussed earlier. Open it up and you should see something like this:</p>
<pre>class IcecreamCrazeSchema &lt; GraphQL::Schema
  mutation(Types::MutationType)
  query(Types::QueryType)
end</pre>
<p>In GraphQL, there are two concepts that lie at the center of everything: fields and object types. An object type is very much like an object in OOP. It holds state and can be things like <code>Car</code> and <code>IceCreamCone</code>. A field is like an attribute on an object - things like <code>wheels</code> and <code>numberOfScoops</code>. The GraphQL schema starts with what are called <strong>root types</strong> - these are just fields that allow us to enter into our schema to actually retrieve information or do things. The three root types are:</p>
<ul>
<li><strong>Query</strong> - this is used for retrieving data</li>
<li><strong>Mutation</strong> - used for <em>changing</em> data; these are said to have "consequences" (think in terms of actions such as "creating a user" or "liking a post")</li>
<li><strong>Subscription</strong> - this is the GraphQL concept for "real-time updates"; normally would be backed by a websocket connection or the like</li>
</ul>
<p>As we can see, our <code>IcecreamCrazeSchema</code> already has the first two defined with examples.</p>
<p>There is a familiar pattern in rails where you create a base class for your application's classes of that type to inherit off of. This allows you to put common logic in a single place. Examples would be <code>ApplicationController</code> and <code>ApplicationRecord</code>. In keeping with that, the new class-based API encourages us to use that pattern, and luckily the generator command went ahead and created a bunch of these for us.</p>
<p>Let's take a look at the first one, <code>BaseObject</code>:</p>
<pre># app/graphql/types/base_object.rb</pre>
<pre>class Types::BaseObject &lt; GraphQL::Schema::Object
end</pre>
<p>All of our types (these are synonymous with an object type in GraphQL) are going to now inherit off of this base type. Let's go ahead and open up <code>app/graphql/types/query_type.rb</code> and you'll see that it inherits off of <code>BaseObject</code>:</p>
<pre>class Types::QueryType &lt; Types::BaseObject
  # Add root-level fields here.
  # They will be entry points for queries on your schema.

  # TODO: remove me
  field :test_field, String, null: false,
    description: "An example field added by the generator"
  def test_field
    "Hello World!"
  end
end</pre>
<p>Before we move on, we'll take a closer look at this. We've got several things happening here.</p>
<p>First we've got <code>field</code>, which is defining a GraphQL field on our object type. The first argument, <code>:test_field</code> is the name of the field.</p>
<p>The second argument, <code>String</code>, defines the return type.</p>
<p>Then we've got this especially curious keyword argument: <code>null: false</code>. What's that all about?</p>
<p>In GraphQL, you have to specify whether or not a field is nullable. This allows the client to understand whether or not they can always expect a valid value from you. In this case, we're going to specify that the field can <strong>not</strong> be null - it will always return a <code>String</code> as specified by the return type. If we changed this to <code>null: true</code>, then we could return a <code>nil</code> value without GraphQL blowing up.</p>
<p>We then specify a <code>description</code>, which allows you to document what the field is for. This <code>description</code> field is returned during introspection as well, meaning that we can see this in GraphiQL.</p>
<p>At the end, we define a method called <code>test_field</code>. This is our resolver method. In GraphQL, each field has what's referred to as a "resolver" - basically just a function or method that specifies how to get the data that should be returned for that field. You'll notice that the method has the same exact name as the field above it does - this allows the gem to find the correct resolver for the field that's being requested and run the code for it.</p>
<p>Now let's go ahead and open up <code>app/graphql/types/mutation_type.rb</code>, and take a look:</p>
<pre>class Types::MutationType &lt; Types::BaseObject
  # TODO: remove me
  field :test_field, String, null: false,
    description: "An example field added by the generator"
  def test_field
    "Hello World"
  end
end</pre>
<p>We've got the same kind of thing here, except that it's for our mutation root type rather than the query root type.</p>
<p>There are a few other files under <code>types</code> that you can feel free to take a look at, but they are pretty much empty and are much the same as <code>BaseObject</code>, just for other GraphQL concepts (eg. enums).</p>
<p>Now, let's take a look at our example schema so far, just to see what we've got going on!</p>
<p><em>NOTE: if you're already familiar with GraphiQL and/or the <code>graphql</code> gem and are just here for the tutorial/new syntax, feel free to skip this next section.</em></p>
<h2>Using GraphiQL</h2>
<p>Probably the most incredible tool at your disposal when creating a GraphQL API is GraphiQL. There are a couple of other tools like it as well, and each have their own strong suits, but for now we'll just use this because it's the most popular and it was the first one to be created.</p>
<p>Go ahead and download it <a href="https://github.com/skevy/graphiql-app">here</a> - there are several different methods described in the readme. Once you've got it downloaded, go ahead and boot up your rails server with <code>rails s</code> and then open up GraphiQL.</p>
<p>Now, here's a quick rundown of what GraphiQL provides:</p>
<ul>
<li>A query editor that automatically formats your query for you</li>
<li>Syntax highlighting</li>
<li>Error highlighting (so if you misspell a field, it will tell you, just like your editor/IDE would!)</li>
<li>Autocomplete</li>
<li>Autosuggestions</li>
<li>Query results are shown in the middle</li>
<li>A <code>Docs</code> tab on the right allows you to view the schema, drilling in to see what's available to you, any documentation, and how to use things</li>
</ul>
<p>That's pretty impressive, eh? I mean, you can't really get that fancy with REST!</p>
<p>Now, up at the top, you should see a box for your GraphQL endpoint. Put in "http://localhost:3000/graphql", and it should populate your docs automatically (refresh if it doesn't). You should now be looking at something like this:</p>
<p><img class="alignnone size-large wp-image-429" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-05-20-at-1.59.04-PM-1024x643.png" alt="" width="700" height="440" /></p>
<p>Go ahead and click on <code>Query</code> in the docs pane:</p>
<p><img class="alignnone size-large wp-image-430" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-05-20-at-2.00.03-PM-1024x643.png" alt="" width="700" height="440" /></p>
<p>What we're seeing is the details from our <code>QueryType</code> back in the code! Notice that it shows us the <code>testField</code>, which the gem automagically camelCased for us to match javascript conventions for the front-end (<code>test_field</code> to <code>testField</code>), the return type <code>String!</code> and the <code>description</code> text beneath it. It may help to spend some time looking between that file and this page to get an understanding of how these details get represented to the client.</p>
<p>A quick aside: you may be wondering about that exclamation mark after the word "String". This is the GraphQL way of saying "this is a non-null value" - what we specified on the ruby side as <code>null: false</code>. If the value were nullable (<code>null: true</code>), then the exclamation mark would not be present.</p>
<p>You can back up to the root and drill into the <code>mutation</code> field as well if you'd like - you'll see something similar. In case you didn't notice, there's also a search bar within the docs so that you can type in what you're looking for and find it quickly.</p>
<p>Now, let's execute our first query! In the left pane, type out the following (it may be tempting to copy/paste, but if you've never seen it before, I highly recommend typing this by hand so you can see the power of the editor and GraphQL type system at work together - it's incredible!):</p>
<pre>{
  testField
}</pre>
<p>Now hit the "play" button (or use the keyboard shortcut <code>cmd + enter</code> on mac) and you should see the middle section fill in with the response from the server:</p>
<p><img class="alignnone size-large wp-image-431" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-05-20-at-2.09.25-PM-1024x643.png" alt="" width="700" height="440" /></p>
<p>This is pretty cool, and we're still just using an example right now!</p>
<h2>I Scream, You Scream</h2>
<p>This is cool, but again, we haven't really gotten into our data model yet, which is where GraphQL really shows it's strength.</p>
<p>So, first things first: let's create some tables!</p>
<p>For right now, we'll start basic. We'll have a <code>User</code> model that <code>has_many</code> <code>Post</code>s. Super simple!</p>
<p>First, run the generators and migrations:</p>
<pre>$ rails g model User first_name:text last_name:text email:text favorite_ice_cream_flavor:text 
$ rails g model Post body:text user:references
$ rails db:migrate</pre>
<p>Make sure to open up your <code>User</code> model and add <code>has_many :posts</code> so we can have the two-way relationship. <em>This will be important for what we're about to do.</em></p>
<p>Let's go ahead and get some data in there too. Stick this in your <code>db/seeds.rb</code> file:</p>
<pre>plain_jane = User.create(first_name: 'Plain', last_name: 'Jane', email: 'plainjane@icecreamsogood.yummy', favorite_ice_cream_flavor: 'Vanilla')
timmy = User.create(first_name: 'Timmy', last_name: 'Crain', email: 'timc@icecreamsogood.yummy', favorite_ice_cream_flavor: 'Rocky Road')
fancy_pants = User.create(first_name: 'Mr.', last_name: "BetterThanU", email: 'trollin@icecreamsogood.yummy', favorite_ice_cream_flavor: "As if you would have ever heard of it.")

plain_jane.posts &lt;&lt; Post.new(body: "Vanilla is definitely the best flavor. You can literally add it to anything and it tastest good!")
plain_jane.posts &lt;&lt; Post.new(body: "Anything but vanilla is too fancy for me! Keep it simple!")

fancy_pants.posts &lt;&lt; Post.new(body: "Real ice cream lovers wouldn't eat this vanilla crap. And chocolate? I mean, come on! Plebs.")</pre>
<p>Then seed the database with those values:</p>
<pre>$ rails db:seed</pre>
<p>Great, we've got some test data!</p>
<p>Now we need to create some GraphQL types for both of these. First, we'll create the user type:</p>
<pre># app/graphql/types/user_type.rb</pre>
<pre>module Types
  class UserType &lt; BaseObject
    description 'A user within the system'

    field :id, ID, null: false
    field :first_name, String, null: false
    field :last_name, String, null: false
    field :email, String, null: false
    field :favorite_ice_cream_flavor, String, null: true
    field :posts, [Types::PostType], null: false
  end
end</pre>
<p>We've seen a majority of this already. What we're doing is describing which fields on a user we want to expose through our API. You'll notice that we've got two new return types going on here.</p>
<p>First, for <code>field :id</code>, we specify that the return type can be <code>ID</code>. This is a special scalar in GraphQL that just represents a unique id for the object in question. An <code>ID</code> can be either a string or an integer, but it gets converted to a string when returning to the client.</p>
<p>Then down at the bottom we've got:</p>
<pre>field :posts, [Types::PostType], null: false</pre>
<p>What this is saying is that the <code>posts</code> field should return an array of <code>PostType</code>'s. We haven't created that type yet - the important thing to take from this is that a return type for a field can either be a scalar or a GraphQL object type.</p>
<p>Let's go ahead and create the <code>PostType</code> now:</p>
<pre>#app/graphql/types/post_type.rb</pre>
<pre>module Types
  class PostType &lt; BaseObject
    description 'A post by a user of the system'

    field :id, ID, null: false
    field :body, String, null: false
    field :author, Types::UserType, null: false, method: :user
  end
end</pre>
<p>And now we're seeing another new thing! On our <code>author</code> field, we see that we're returning a <code>UserType</code>, but then we've got this <code>method: :user</code> bit. What does that do exactly?</p>
<p>I will explain this... very soon (for people already familiar with the previous syntax, this is the new keyword argument for <code>property</code>). But first, we need to finish what we were doing!</p>
<p>We've got our two new types, but they're currently not connected to the schema in any way - we can't yet query for any of this information! Let's fix that by going into our <code>QueryType</code> and replacing  the <code>test_field</code> with the following:</p>
<pre># app/graphql/types/query_type.rb

field :users, [Types::UserType], 'Retrieve a list of all users', null: true

def users
  User.all
end</pre>
<p>And so now it all comes together! We've got our field that will allow us to get a list of users. Let's talk about exactly how this works.</p>
<p>When you request the <code>users</code> field in a GraphQL query, the gem will run the <code>users</code> method to "resolve" the field. The gem will then take whatever value gets returned by the resolver, and attempt to coerce it into the return type specified by the field, which in this case is an array of <code>UserType</code> (<code>[Types::UserType]</code>).</p>
<p>For each item, the gem will instantiate a new object for the return type (<code>UserType</code> here), and pass the item into it (accessible through the <code>object</code> method in the type). It will then go through this same process of looking at the fields that were requested, and searching for resolvers with the same name as the field.</p>
<p>"Hey wait," you may be thinking, "the types we just created don't have resolver methods!"</p>
<p>Astute observation - you're right! And in this case, we actually <strong>don't need to write those methods</strong>. One of the cool things the gem will do, is if you haven't defined a resolver method for a field, it will assume that the field name maps to a method on the object that was passed into the type.</p>
<p>In practice - since we didn't define a <code>first_name</code> resolver method in <code>Types::UserType</code>, it will assume that the <code>User</code> passed into <code>UserType</code> has a method called <code>first_name</code> and attempt to call it. It's basically the same as if we'd written a resolver method like so:</p>
<pre>def first_name
  object.first_name
end</pre>
<p>Except that we didn't need to actually write it! Pretty cool, huh?</p>
<p>Now, with that explanation out of the way, we can wrap back around to that line on the <code>PostType</code>:</p>
<pre>field :author, Types::UserType, null: false, method: :user</pre>
<p>So what does that <code>method: :user</code> do? Well, technically there's no method on our <code>Post</code> model called <code>author</code>. Rather than needing to define a resolve method just to alias this field however, we can use the <code>method</code> keyword argument and tell it which method to call. It's really just a shorthand for:</p>
<pre>def author
  object.user
end</pre>
<h2>We All Scream For Ice Cream!</h2>
<p>Okay, now let's see this in action! Pop back over into GraphiQL and refresh to see your updated schema in the docs tab. Now, let's write a query over in the editor tab on the left:</p>
<pre>{
  users {
    firstName
    lastName
    email
    favoriteIceCreamFlavor
    posts {
      body
      author {
        id
        firstName
      }
    }
  }
}</pre>
<p>So here, we're asking for a list of users, which will hit that <code>User.all</code> line in our <code>QueryType</code>, then we're asking for some details about each user. We also are asking for a list of all the user's posts, along with the body of each post. And then, as an example of the graph nature of GraphQL, we ask for something cyclical that we normally wouldn't need probably in this case: the <code>author</code> and their <code>id</code> and <code>first_name</code>. Submit the query and watch the magic!</p>
<p><img class="alignnone size-large wp-image-432" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-05-20-at-3.32.13-PM-1024x653.png" alt="" width="700" height="446" /></p>
<p>Is that cool or what?</p>
<h2>Assignment</h2>
<p>Oh yes, we're going to be having assignments in this tutorial series :) I find that they are a helpful learning tool, and my goal is to help you learn GraphQL as well as I can!</p>
<p>In this first part of the tutorial, we learned how to get GraphQL set up and running in a rails API. We also learned how to create a query and various different types that we can expose through our API, as well as how to express relationships between types and submit queries to ask for the data we want.</p>
<p>For your first assignment, <strong>add a new query at the root level (in the <code>QueryType</code>) that you can use to retrieve a list of posts</strong>. If you figure this out really quickly and want to try your hand at something a bit more complex, see if you can figure out how to create a query that allows you to ask for a single post by <code>id</code>. I'll show the code for this at the beginning of part 2.</p>
<p>Good luck!</p>
<h2>Closing Time</h2>
<p>Time to close up shop for part 1. There's still tons of stuff for us to cover: mutations, cleaning up the code, tests, pagination, error handling, and those pesky N+1 queries that you may or may not have noticed in your logs, just to name a few! Make sure to keep an eye out, and sign up for my newsletter to make sure you know when part 2 comes out!</p>
<p>Throughout this tutorial, I am going to be pushing code to a github repo for your convenience if you get stuck, or in case you'd prefer to just pull it down and look through the code that way rather than write it all yourself. The <code>master</code> branch will reflect the furthest point I've gotten to with the tutorial so far, and I will have a separate branch for each part, named after the blog post associated (so the branch for this post is called <code>part-1-the-basics</code>). <a href="https://github.com/mengledowl/icecream-craze">Take a peek here!</a></p>
<p>I will also be posting links to each part here as they come out.</p>
<p>Hopefully you enjoyed the first part to this tutorial, see you again soon for the next part!</p>
