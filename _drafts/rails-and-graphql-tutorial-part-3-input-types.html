---
layout: post
title: 'Rails and GraphQL Tutorial Part 3: Input Types'
date: 
type: post
parent_id: '0'
published: false
password: ''
status: draft
categories:
- Ruby on Rails
- Tutorials
tags: []
meta:
  _wpcom_is_markdown: '1'
  _edit_last: '1'
author:
  login: admin
  email: mengledowl@gmail.com
  display_name: Matt Engledowl
  first_name: ''
  last_name: ''
permalink: "/"
---
<p>Welcome back for part 3 of our tutorial series! Last time, we went over mutations, and even got into the <code>context</code> object and <code>arguments</code> a little bit. This time, we will be going over input types - what they are, what they're good for, and how to use them!</p>
<h2>Part 2 Assignment Solution</h2>
<p>The assignment from part 2 was to add a mutation that allowed updating the current user's details. Here's what the solution for that looks like:</p>
<pre># app/graphql/types/mutation_type.rb

</pre>
<pre>field :current_user_update, Types::UserType, 'Update the details of the current user', null: false do
  argument :first_name, String, 'Change the user\'s first name', required: false
  argument :last_name, String, 'Change the user\'s last name', required: false
  argument :email, String, 'Change the user\'s email', required: false
  argument :favorite_ice_cream_flavor, String, 'Change the user\'s favorite ice cream flavor', required: false
end

def current_user_update(**kwargs)
  context[:current_user].update(**kwargs)
  context[:current_user]
end</pre>
<p>After going through part 2 and learning about arguments and the context, this should be pretty familiar and simple to understand. If you're not super familiar with ruby, the <code>**kwargs</code> bit might be throwing you for a loop. The <code>**</code> syntax before the parameter in the method definition is simply a way of expecting a group of key-word arguments and bundling them all up into the parameter <code>kwargs</code>. Then you can use the <code>**</code> syntax again when passing into a method to expand the keyword arguments out.</p>
<p>Essentially, this is a shorter way of writing:</p>
<pre>def current_user_update(first_name:, last_name:, email:, favorite_ice_cream_flavor:)
  context[:current_user].update(first_name: first_name, last_name: last_name, email: email, favorite_ice_cream_flavor: favorite_ice_cream_flavor)
  context[:current_user]
end</pre>
<p>You should now be able to update the current user, and since all of the arguments have <code>required: false</code>, you can pass in any combination of them which you wish to use!</p>
<p><img class="alignnone size-large wp-image-467" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-06-23-at-4.35.23-PM-1024x665.png" alt="" width="700" height="455" /></p>
<p>The more security-conscious developer may have noticed that we're taking a list of arguments in directly from the client and splatting them in (that's a term for <code>**</code>), which could be setting off some internal alarms.</p>
<p>In a RESTful rails API, we would definitely need to worry about this, and would need to cover for it using something like strong parameters to white-list which parameters can be passed and which get ignored. However, in GraphQL, this is a non-issue because we've already defined something that essentially does the work of strong parameters (where we define the arguments)! To see this at work, try commenting one of the arguments out, and then submit a mutation with that argument included in the mutation. It will blow up and not allow the mutation to succeed. This is the type system at work here, keeping your API safe and secure from unwanted parameters being passed in! Mass assignment is safe in this case.</p>
<h2>Input Types</h2>
<p>So what exactly <em>are </em>"input types"?</p>
<p>Basically, they are "complex objects" that you can pass in as arguments. There are a few reasons that you might want to use them:</p>
<p><strong>They allow serializing an object into the query more easily without having to mess with the query string itself</strong></p>
<p>I mentioned in part 1 of this tutorial series {{ TODO: link to part 1 }} that I was only really planning to go over how to do things on the server-side, but it's still important for us to consider how the client might use our API so as to make it easier for them to use. With this in mind, think about how you would perform a mutation in javascript from the client-side. Now imagine that the mutation has a list of arguments that come from a form, or from some sort of state being managed on the client - how do you get those into your mutation (which is just a string)?</p>
<p><em>Hint: input types + query variables.</em></p>
<p><strong>They allow you to share common arguments between fields (this isn't something I do a lot, but it can be helpful from time to time)</strong></p>
<p>Imagine that we had another mutation for <code>currentUserCreate</code>. It would probably have the same exact arguments as <code>currentUserUpdate</code>, yes? I should add a caveat here that I currently <em>don't use input types for this case anymore</em>. At least, not with mutations, and there's a reason for that which we'll get to later. For now, suffice to say that it has to do with flexibility in evolving your schema as time goes on.</p>
<p><strong>They allow you to nest objects inside of each other.</strong></p>
<p>This another one that I don't typically do a whole lot because many times it can indicate that my query/mutation is trying to do too much and there is another query/mutation hiding in there begging to be broken out. However, there are times when this can be very useful, such as when you need to implement filtering.</p>
<p>There are other more advanced reasons that you might find them useful as well (eg. more complex schemes for requiring groups of arguments), but they're not worth getting into right now.</p>
<h2>Our First Input Type</h2>
<p>Alright, let's get to the code then! If you didn't add the code for the last assignment, now would be a good time to do it.</p>
<p>Input types are pretty simple to create in ruby. As you may remember from previous posts, we've already got a bunch of "base" classes to work with, including a <code>BaseInputObject</code>. This should currently be sitting under <code>app/graphql/types</code>, but I like to have my files organized a bit differently. Create a new directory directly under <code>app/graphql</code> called <code>inputs</code> and move  it there. Don't forget to update the module:</p>
<pre># app/graphql/inputs/base_input_object.rb

</pre>
<pre>module Inputs
  class BaseInputObject &lt; GraphQL::Schema::InputObject
  end
end</pre>
<p><em>Side note: input type == input object. Those names refer to the same concept and are interchangeable.</em></p>
<p>This is our base input object which all of our other input objects will inherit off of, allowing us to share some behavior between them all if we need it.</p>
<p>Next, we need to create a new class to house the arguments in question:</p>
<pre># app/graphql/inputs/current_user_update_input.rb

</pre>
<pre>module Inputs
  class CurrentUserUpdateInput &lt; BaseInputObject
    description 'Used for updating attributes on the current user'

    argument :first_name, String, 'Change the user\'s first name', required: false
    argument :last_name, String, 'Change the user\'s last name', required: false
    argument :email, String, 'Change the user\'s email', required: false
    argument :favorite_ice_cream_flavor, String, 'Change the user\'s favorite ice cream flavor', required: false
  end
end</pre>
<p>This is pretty simple - as I mentioned before, we're inheriting off of the original <code>BaseInputObject</code> we've created, we have a <code>description</code> which we've seen numerous times, and then we just declare the objects that are part of our input. All we've done with the arguments is grab them out of our <code>currentUserUpdate</code> mutation.</p>
<p>Speaking of which, we need to update our mutation to use the new input object we just created, as well as updating our resolver since we are no longer just accepting those arguments at the "root" of the arguments list (so to speak). Pop open your mutation type and update the <code>current_user_update</code> details as such:</p>
<pre># app/graphql/mutation_type.rb

</pre>
<pre>field :current_user_update, Types::UserType, 'Update the details of the current user', null: false do
  argument :input, Inputs::CurrentUserUpdateInput, required: true
end

def current_user_update(input:)
  context[:current_user].update(input.to_h)
  context[:current_user]
end</pre>
<p>All we did here is remove all the arguments from <code>field :current_user_update</code> (since they are now housed in <code>Inputs::CurrentUserUpdateInput</code>) and add a new argument called <code>input</code>, using our new input object as the type that the argument accepts. This means all of our arguments will be under <code>input</code> now - we'll see what that looks like when writing our mutation here shortly.</p>
<p>We've also updated our resolver to only take <code>input</code> now. The arguments are all contained inside of <code>input</code>, but they're not in the format that <code>update</code> expects them to be, so we convert it to a hash.</p>
<h2>Re-writing Our Mutation</h2>
<p>Now we can head back to GraphiQL and write another mutation using this new input object as an argument. Here's how it might look at first pass:</p>
<pre>mutation {
  currentUserUpdate(
    input: {
      email: "pj@icecreamsogood.yummy"
    }
  ) {
    id
    email
    firstName
  }
}</pre>
<p>So now, we've simply moved the arguments down inside of <code>input</code> - it looks exactly like nested JSON.</p>
<p>But wait - this doesn't solve the first problem we discussed above about serializing data into the query easily! How do we pull that in?</p>
<p>In GraphQL, there's a concept called <em>query variables</em>. This is basically a way of <strong>passing variables into the query string <em>without</em> having to perform string manipulation to get dynamic values into your query</strong>. Here's what the query looks like using query variables instead of putting the email directly into the mutation:</p>
<pre>mutation UpdateUser($userInput: CurrentUserUpdateInput!) {
  currentUserUpdate(input: $userInput) {
    id
    email
    firstName
  }
}</pre>
<p>If you've never seen this before, you're probably WTF-ing pretty hard right now. I promise it's simpler than it may seem at first! Let's finish really quick and then I'll come back and explain in case it doesn't quite make sense still.</p>
<p>Now, if you look at GraphiQL in the bottom left-hand corner, there should be something that says "<strong>query variables</strong>". If it's not already expanded with a textbox available to you, go ahead and click on the text to expand it. This is where you can define the values that we're referring to in our mutation above.</p>
<p>Query variables are just JSON. Paste the following into your query variables tab:</p>
<pre>{
  "userInput": {
    "email": "pj@icecreamsogood.yummy"
  }
}</pre>
<p>Here's what it looks like in GraphiQL at this point:</p>
<p><img class="alignnone size-large wp-image-471" src="{{ site.baseurl }}/assets/images/Screen-Shot-2018-07-06-at-9.05.36-AM-1024x665.png" alt="" width="700" height="455" /></p>
<p>So here's what's going on.</p>
<p>The first thing we had to do was add <code>UpdateUser</code> directly after <code>mutation</code>. This is simply a name for the mutation - it can be anything you want it to be and has no effect on anything other than to allowing us to use query variables (well, and <a href="https://graphqlme.com/2018/06/16/does-the-graphql-spec-contradict-itself/">allowing you to have multiple queries/mutations and telling the server which to run using operation name</a>, but that's a different discussion entirely).</p>
<p>Then, we've got some weirdness happening after <code>UpdateUser</code> inside those parenthesis. Basically, what we've got there is the name of a query variable <code>$userInput</code> followed by the <em>type which that variable represents</em> <code>CurrentUserUpdateInput!</code>. So basically this is saying "Inside this mutation, I'm going to refer to a query variable called "userInput", and "userInput" is going to be used in place of a <code>CurrentUserUpdateInput</code> argument which is required".</p>
<p>Finally, inside our mutation, we've replaced our list of arguments inside of <code>input</code> with <code>$userInput</code> which is just another reference to our <code>userInput</code> argument.</p>
<p>Down in the query variables, we specify what value the <code>userInput</code> variable has using JSON - any arguments that are inside <code>userInput</code> are expected to map directly to an argument inside of our <code>CurrentUserUpdateInput</code> type.</p>
<p>You should be able to submit the mutation and see it complete successfully. If you're curious exactly what this does, you can take a look at your logs and you'll see something like this:</p>
<pre>Parameters: {"query"=&gt;"mutation UpdateUser($userInput: CurrentUserUpdateInput!) {\n currentUserUpdate(input: $userInput) {\n id\n email\n firstName\n }\n}", "variables"=&gt;{"userInput"=&gt;{"email"=&gt;"pj@icecreamsogood.yummy"}}, "operationName"=&gt;"UpdateUser", "graphql"=&gt;{"query"=&gt;"mutation UpdateUser($userInput: CurrentUserUpdateInput!) {\n currentUserUpdate(input: $userInput) {\n id\n email\n firstName\n }\n}", "variables"=&gt;{"userInput"=&gt;{"email"=&gt;"pj@icecreamsogood.yummy"}}, "operationName"=&gt;"UpdateUser"}}</pre>
<p>That's just rails printing out the parameters for us. It's also kinda hard to look at so let's clean it up a bit so we can examine more closely what it's telling us:</p>
<pre>{ "query" =&gt; "...", "variables" =&gt; { "userInput" =&gt; { "email" =&gt; "pj@icecreamsogood.yummy" } } }</pre>
<p>So first we've got <code>query</code>, which is just the raw string containing the mutation text. Then we've got <code>variables</code> which upon further inspection is just the value we put in the "Query Variables" section! Basically, we're just passing the query variables as a separate parameter, and then the GraphQL gem just "knows" how to handle it.</p>
<p>If you are interested, you can read more about input objects/types <a href="https://graphqlme.com/2017/11/04/input-types/">here</a> - just keep in mind that the ruby code here uses the old syntax.</p>
<h2>Assignment</h2>
<p>Your assignment this time is to tinker and reflect on/answer the following questions:</p>
<ul>
<li>Why might I have made the name of the input type so specific to the mutation rather than more generic so it could be feasibly used in other mutations?</li>
<li>What happens if you change the line <code>argument :input, Inputs::CurrentUserUpdateInput, required: true</code> to have <code>required: false</code>?</li>
<li>What happens if you rename the input type to something else using <code>graphql_name</code>?</li>
<li>Can you change the name of the query variable? How?</li>
<li>What happens if you try to pass another key/value inside of the <code>userInput</code> query variable that isn't one of the available arguments on the input object?</li>
<li>Can you pass multiple arguments at once inside of the <code>userInput</code> query variable?</li>
</ul>
<p>Look for the answers to these questions in Part 4!</p>
